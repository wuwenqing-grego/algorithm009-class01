# 算法训练营

## 如何高效学习

### 基本原则

- 三分看视频，七分做练习

	- 倍速播放，难点暂停反复看

- 摒弃旧习惯

	- 不要死磕

		- 思考不超过5分钟，实现不超过15分钟

	- 高效刷题

		- 敢于背优秀代码，多看高票回答

### 精进三部曲

- chunk it up

	- 庖丁解牛

		- 建立知识树

- deliberate practicing

	- 刻意练习

		- 过遍数
		- 练习弱项

- feedback

	- 即时反馈

		- 主动

			- high vote solution

		- 被动

			- Code Review

### 切题四件套

- Clarification

	- 多看几遍题目，和面试官确认

- Possible solutions

	- 把所有可能解法都过一遍，比较后选择可能最优

- Coding

	- 写代码

- Test cases

	- 测试用例

### 五毒神掌

- 第一遍

	- 5分钟思考，没有思路直接看解法

		- 比较多种解法优劣
		- 背诵默写好的解法

- 第二遍

	- 马上自己写

		- debug 直到通过

- 第三遍

	- 第二天再做一遍

- 第四遍

	- 一周后再做一遍

		- 一定要去国际版看高票解答！

- 第五遍

	- 面试前再做一遍

### 编码技巧

- 提升效率

	- 熟练使用 IDE 快捷方式

- 自顶向下编程方式

	- 写代码类似写报纸

		- 重点在前，细节在后

	- 先思考主干逻辑

		- 写空函数，直接用

	- 再考虑实现细节

		- 用 IDE 补全函数声明

## 数据结构与算法总览

### 数据结构

- 一维

	- 基础

		- 数组：array
		- 链表：linked list

	- 高级

		- 栈：stack
		- 队列：queue

			- 双端队列：deque

		- 集合：set
		- 映射：map/hash

- 二维

	- 基础

		- 树：tree
		- 图：graph

	- 高级

		- 二叉搜索树：BST/red-black tree/AVL
		- 堆：heap
		- 并查集：disjoint set
		- 字典树：Trie

- 特殊

	- 位运算：Bitwise
	- 布隆过滤器：BloomFilter
	- 缓存：LRU Cache

### 算法

- 基石

	- if/else，switch：branch

		- 判断

	- for/while，loop：iteration

		- 循环

	- devide&conquer，backtrace：recursion

		- 递归

- 派生

	- Search

		- 搜索

	- Dynamic Programming

		- 动态规划

	- Binary Search

		- 二分查找

	- Greedy

		- 贪心算法

	- Math&Geometry

		- 数学

## 复杂度分析

### 时间复杂度

- 循环直接看最大次数
- 递归

	- 画出递归树，对所有情况求和
	- Master Theorem

		- 常用分治递推公式

### 空间复杂度

- 数组长度
- 递归深度

	- 递归树的高度

## 数组、链表、跳表

### 基本概念

- 一维基础数据结构

	- 顺序存储

		- 数组

			- prepend、append、lookup

				- O(1)

			- insert、delete

				- O(n)

	- 链式存储

		- 链表

			- prepend、append、insert、delete

				- O(1)

			- lookup

				- O(n)

- 派生数据结构

	- 跳表

		- 只能用于元素有序的情况

			- 对标平衡树和二分查找

		- 一维数据结构的优化常常用到的思想：升维

			- 多一层维度就多一层信息

		- 时间：O(logn)
		- 空间：O(n)

### 解题技巧

- 一维数组坐标变换问题

	- 283.移动零
	- 双指针法

		- 一个指针用于遍历数组
		- 一个指针用于记录变换后的结果

- 一维数组求极值问题

	- 11.盛水容器
	- 左右夹逼法

		- 数组头尾指针逐渐向中间逼近
		- 两者相遇时即遍历完成

- 350.数组交集

	- 进阶三问有疑问

### 解题总纲

- 没有思路的问题

	- 暴力求解
	- 考虑简单情况
	- 找最近重复子问题

		- 循环

			- 原问题的碎片

		- 递归

			- 原问题的缩影

## 栈、队列

### 基本概念

- Stack

	- 先入后出

		- 添加、删除：O(1)
		- 查询：O(n)

- Queue

	- 先入先出

		- 添加、删除：O(1)
		- 查询：O(n)

- Deque: Double-Ended Queue

	- 栈和队列的结合体

		- 添加、删除：O(1)
		- 查询：O(n)

- Priority Queue

	- 插入：O(1)
	- 取出：O(logn)
	- 可有heap、BST、treap多种实现

### 解题技巧

- 栈问体特点

	- 最近相关性
	- 数据只在一段出入

- 队列问题特点

	- 先来后到性
	- 数据会在两端出入

- 单调栈、单调队列

	- 适合解决乱序动态求最值的问题
	- 84.柱状图中最大的矩形
	- 239.滑动窗口最大值

## 哈希表、映射、集合

### 基本概念

- 哈希表

	- Map/Set

### 解题技巧

## 树、二叉树、二叉搜索树

### 基本概念

- 树

	- 相当于链表的升维

		- 一个next指针变为多个next指针

	- 链表是树的特例，树是图的特例
	- 树的结构天生适合递归，而不适合循环

- 树的遍历

	- 前序
	- 中序
	- 后序

- BST

	- 左子树 < 节点 < 右子树

### 解题技巧

- 二叉树遍历

	- 递归解法
	- 迭代解法

		- 递归的本质就是压栈，故递归写法都可通过栈转换为迭代写法
		- 红黑栈写法模拟函数递归
		- 94.二叉树的中序遍历

## 堆、二叉堆

### 基本概念

- heap

	- 抽象

		- 可以快速找到一组数中最大或最小值的数据结构

	- 实现

		- 二叉堆

			- 基于二叉树

				- 一棵完全二叉树
				- 任意节点值 >= 子节点值

		- 斐波那契堆

			- 基于多叉树

	- 操作

		- find-max：O(1)
		- delete-max：O(logn)

			- 堆尾替换头部，向下堆化

		- insert/create：O(logn)/O(1)

			- 加在堆尾，向上堆化

### 解题技巧

- Top K问题熟练掌握
- 040.最小的k个数
- 347.前k个高频元素

## 图

## 泛型递归

### 基本概念

- 递归也是一种循环

	- 通过调用函数体自身来实现

		- 编译后两者没有太大区别

	- 计算机底层由汇编实现，而汇编语言没有循环

		- 它会跳到指定的代码处反复执行

- 类比盗梦空间

	- 每一层梦境是全新的世界，互相不会影响，即为函数上下文
	- 主角可以穿梭于层层梦境之间，即为函数参数
	- 递进与返回必须依次发生，不可跳转

- 递归双子

	- 终止条件
	- 递推公式

		- 处理本层逻辑
		- 进入下层逻辑
		- 清理本层数据

- 递归三要点

	- 不要进行人肉递归！
	- 寻找最近重复子问题！
	- 把握数学归纳法思维！

### 解题技巧

- 注意递归进入下一层时，传参时不要使用++/--运算符！

	- 这会将本层的参数修改掉，从而产生错误

- 注意使用for...in...时，返回的是数组的键，不是值！

	- 数组也是对象，只不过键是固定的，为自然数组

- 22.括号生成

## Js

### 基本概念

- 函数

	- 作用域

		- 函数本身也是一个值，也有自己的作用域
		- 它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。

	- 参数

		- 原始类型的值(数值、字符串、布尔值)，传递方式为传值传递(passes by value)

			- 即，在函数体内修改参数值，不会影响函数外部

		- 复合类型的值(数组、对象、其他函数)，传递方式是传址传递(pass by reference)

			- 即，传入函数的是原始值的地址，因此在函数内部修改参数，将会影响到原始值
			- 注意，如果函数内部修改的不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值，因为相当于地址变了

- Set/Map

	- Set

		- 可用于数组/字符串去重

			- [...new Set(array)]
			- [...new Set('ababbc')].join('')

	- Map

- 数组

	- slice

		- 不会改变原数组
		- 返回值为原数组的浅拷贝

	- splice

		- 会改变原数组
		- 返回值为数组形式的被修改内容

*XMind - Trial Version*