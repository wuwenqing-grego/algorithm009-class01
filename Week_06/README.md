# 算法训练营

## 如何高效学习

### 基本原则

- 三分看视频，七分做练习

	- 倍速播放，难点暂停反复看

- 摒弃旧习惯

	- 不要死磕

		- 思考不超过5分钟，实现不超过15分钟

	- 高效刷题

		- 敢于背优秀代码，多看高票回答

### 精进三部曲

- chunk it up

	- 庖丁解牛

		- 建立知识树

- deliberate practicing

	- 刻意练习

		- 过遍数
		- 练习弱项

- feedback

	- 即时反馈

		- 主动

			- high vote solution

		- 被动

			- Code Review

### 切题四件套

- Clarification

	- 多看几遍题目，和面试官确认

- Possible solutions

	- 把所有可能解法都过一遍，比较后选择可能最优

- Coding

	- 写代码

- Test cases

	- 测试用例

### 五毒神掌

- 第一遍

	- 5分钟思考，没有思路直接看解法

		- 比较多种解法优劣
		- 背诵默写好的解法

- 第二遍

	- 马上自己写

		- debug 直到通过

- 第三遍

	- 第二天再做一遍

- 第四遍

	- 一周后再做一遍

		- 一定要去国际版看高票解答！

- 第五遍

	- 面试前再做一遍

### 编码技巧

- 提升效率

	- 熟练使用 IDE 快捷方式

- 自顶向下编程方式

	- 写代码类似写报纸

		- 重点在前，细节在后

	- 先思考主干逻辑

		- 写空函数，直接用

	- 再考虑实现细节

		- 用 IDE 补全函数声明

## 数据结构与算法总览

### 数据结构

- 一维

	- 基础

		- 数组：array
		- 链表：linked list

	- 高级

		- 栈：stack
		- 队列：queue

			- 双端队列：deque

		- 集合：set
		- 映射：map/hash

- 二维

	- 基础

		- 树：tree
		- 图：graph

	- 高级

		- 二叉搜索树：BST/red-black tree/AVL
		- 堆：heap
		- 并查集：disjoint set
		- 字典树：Trie

- 特殊

	- 位运算：Bitwise
	- 布隆过滤器：BloomFilter
	- 缓存：LRU Cache

### 算法

- 基石

	- if/else，switch：branch

		- 判断

	- for/while，loop：iteration

		- 循环

	- devide&conquer，backtrace：recursion

		- 递归

- 派生

	- Search

		- 搜索

	- Dynamic Programming

		- 动态规划

	- Binary Search

		- 二分查找

	- Greedy

		- 贪心算法

	- Math&Geometry

		- 数学

## 复杂度分析

### 时间复杂度

- 循环直接看最大次数
- 递归

	- 画出递归树，对所有情况求和
	- Master Theorem

		- 常用分治递推公式

### 空间复杂度

- 数组长度
- 递归深度

	- 递归树的高度

## 数组、链表、跳表

### 基本概念

- 一维基础数据结构

	- 顺序存储

		- 数组

			- prepend、append、lookup

				- O(1)

			- insert、delete

				- O(n)

	- 链式存储

		- 链表

			- prepend、append、insert、delete

				- O(1)

			- lookup

				- O(n)

- 派生数据结构

	- 跳表

		- 只能用于元素有序的情况

			- 对标平衡树和二分查找

		- 一维数据结构的优化常常用到的思想：升维

			- 多一层维度就多一层信息

		- 时间：O(logn)
		- 空间：O(n)

### 解题技巧

- 一维数组坐标变换问题

	- 283.移动零
	- 双指针法

		- 一个指针用于遍历数组
		- 一个指针用于记录变换后的结果

- 一维数组求极值问题

	- 11.盛水容器
	- 左右夹逼法

		- 数组头尾指针逐渐向中间逼近
		- 两者相遇时即遍历完成

- 350.数组交集

	- 进阶三问有疑问

### 解题总纲

- 没有思路的问题

	- 暴力求解
	- 考虑简单情况
	- 找最近重复子问题

		- 循环

			- 原问题的碎片

		- 递归

			- 原问题的缩影

## 栈、队列

### 基本概念

- Stack

	- 先入后出

		- 添加、删除：O(1)
		- 查询：O(n)

- Queue

	- 先入先出

		- 添加、删除：O(1)
		- 查询：O(n)

- Deque: Double-Ended Queue

	- 栈和队列的结合体

		- 添加、删除：O(1)
		- 查询：O(n)

- Priority Queue

	- 插入：O(1)
	- 取出：O(logn)
	- 可有heap、BST、treap多种实现

### 解题技巧

- 栈问体特点

	- 最近相关性
	- 数据只在一段出入

- 队列问题特点

	- 先来后到性
	- 数据会在两端出入

- 单调栈、单调队列

	- 适合解决乱序动态求最值的问题
	- 84.柱状图中最大的矩形
	- 239.滑动窗口最大值

## 哈希表、映射、集合

### 基本概念

- 哈希表

	- Map/Set

### 解题技巧

## 树、二叉树、二叉搜索树

### 基本概念

- 树

	- 相当于链表的升维

		- 一个next指针变为多个next指针

	- 链表是树的特例，树是图的特例
	- 树的结构天生适合递归，而不适合循环

- 树的遍历

	- 前序
	- 中序
	- 后序

- BST

	- 左子树 < 节点 < 右子树

### 解题技巧

- 二叉树遍历

	- 递归解法
	- 迭代解法

		- 递归的本质就是压栈，故递归写法都可通过栈转换为迭代写法
		- 红黑栈写法模拟函数递归
		- 94.二叉树的中序遍历

## 堆、二叉堆

### 基本概念

- heap

	- 抽象

		- 可以快速找到一组数中最大或最小值的数据结构

	- 实现

		- 二叉堆

			- 基于二叉树

				- 一棵完全二叉树
				- 任意节点值 >= 子节点值

		- 斐波那契堆

			- 基于多叉树

	- 操作

		- find-max：O(1)
		- delete-max：O(logn)

			- 堆尾替换头部，向下堆化

		- insert/create：O(logn)/O(1)

			- 加在堆尾，向上堆化

### 解题技巧

- Top K问题熟练掌握
- 040.最小的k个数
- 347.前k个高频元素

## 图

### 基本概念

- 组成

	- Vertex

		- 入度、出度
		- 连通

	- Edge

		- 有向、无向
		- 权重

- 表示方法

	- 邻接矩阵
	- 邻接表

- 常用算法

	- DFS/BFS

		- 与树的最大区别在于一定要写visited！

	- 高级算法

### 解题技巧

## 泛型递归

### 基本概念

- 递归也是一种循环

	- 通过调用函数体自身来实现

		- 编译后两者没有太大区别

	- 计算机底层由汇编实现，而汇编语言没有循环

		- 它会跳到指定的代码处反复执行

- 类比盗梦空间

	- 每一层梦境是全新的世界，互相不会影响，即为函数上下文
	- 主角可以穿梭于层层梦境之间，即为函数参数
	- 递进与返回必须依次发生，不可跳转

- 递归双子

	- 终止条件
	- 递推公式

		- 处理本层逻辑
		- 进入下层逻辑
		- 清理本层数据

			- 恢复本层某些变量
			- 考虑是否需要返回值，返回值代表什么

- 递归三要点

	- 不要进行人肉递归！
	- 寻找最近重复子问题！
	- 把握数学归纳法思维！

### 解题技巧

- 注意递归进入下一层时，传参时不要使用++/--运算符！

	- 这会将本层的参数修改掉，从而产生错误

- 注意使用for...in...时，返回的是数组的键，不是值！

	- 数组也是对象，只不过键是固定的，为自然数组

- 22.括号生成

## 分治、回溯

### 基本概念

- 本质上就是递归

	- 递归的本质是重复

		- 最近重复性

			- 子问题不相关

				- 分治

					- Devide
					- Conquer
					- Merge

			- 子问题相关

				- 回溯

					- 遍历决策树

		- 最优重复性

			- 动态规划

### 解题技巧

- 排列、组合、子集问题

	- 本质是n个格子，每格决策一次
	- 决定是选哪个，或者是选不选

- 46.全排列
- 78.子集

## 搜索

### 基本概念

- DFS

	- 实现

		- 递归
		- 手动维护栈

	- 场景

		- 更常用的遍历

- BFS

	- 实现

		- 队列

	- 场景

		- 层序遍历
		- 最短路径

			- Dijkstra算法针对有权图，BFS针对无权图

	- 多源BFS

		- 将多个源点同时放入初始队列即可

- 启发式搜索

	- 深度学习

### 解题技巧

- 1143.最长公共子序列
- 动态规划中的状态转移有两种

	- 正向：状态转移表

		- 通常可由回溯算法演变而来
		- 用循环实现

	- 逆向：状态转移方程

		- 思考反向递推的规律
		- 用递归实现，用缓存优化

	- 寻找递推关系时，不妨从两个角度分别考虑

## 贪心算法

### 基本概念

### 解题技巧

- 45.跳跃游戏||

## 二分查找

## 动态规划

### 基本概念

### 解题技巧

- 198.打家劫舍

	- 用自顶向下的记忆式搜索时，判断之前是否计算过，注意写成如下形式，否则值为零的会被跳过
	- if (dp[i] != undefined) {return dp[i]}

- 363.矩形区域不超过k的最大和

	- 二维数组行和列数相差很大时，两种循环遍历会有差别，自增与比较次数相同
	- 不同之处在于i/j的定义与舍弃次数

## Js速查

### 基本概念

- 函数

	- 作用域

		- 函数本身也是一个值，也有自己的作用域
		- 它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。

	- 参数

		- 原始类型的值(数值、字符串、布尔值)，传递方式为传值传递(passes by value)

			- 即，在函数体内修改参数值，不会影响函数外部

		- 复合类型的值(数组、对象、其他函数)，传递方式是传址传递(pass by reference)

			- 即，传入函数的是原始值的地址，因此在函数内部修改参数，将会影响到原始值
			- 注意，如果函数内部修改的不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值，因为相当于地址变了

- Set/Map

	- Set

		- 可用于数组/字符串去重

			- [...new Set(array)]
			- [...new Set('ababbc')].join('')

	- Map

- 数组

	- slice

		- 不会改变原数组
		- 返回值为原数组的浅拷贝

	- splice

		- 会改变原数组
		- 返回值为数组形式的被修改内容

- 布尔值

	- 以下六类值会被转换成false，其余皆为true

		- undefined
		- null
		- false
		- 0
		- NaN
		- null string

	- 可以活用于if判断语句中

*XMind - Trial Version*