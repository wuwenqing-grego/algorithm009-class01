# 算法训练营

## 如何高效学习

### 基本原则

- 三分看视频，七分做练习

	- 倍速播放，难点暂停反复看

- 摒弃旧习惯

	- 不要死磕

		- 思考不超过5分钟，实现不超过15分钟

	- 高效刷题

		- 敢于背优秀代码，多看高票回答

### 精进三部曲

- chunk it up

	- 庖丁解牛

		- 建立知识树

- deliberate practicing

	- 刻意练习

		- 过遍数
		- 练习弱项

- feedback

	- 即时反馈

		- 主动

			- high vote solution

		- 被动

			- Code Review

### 切题四件套

- Clarification

	- 多看几遍题目，和面试官确认

- Possible solutions

	- 把所有可能解法都过一遍，比较后选择可能最优

- Coding

	- 写代码

- Test cases

	- 测试用例

### 五毒神掌

- 第一遍

	- 5分钟思考，没有思路直接看解法

		- 比较多种解法优劣
		- 背诵默写好的解法

- 第二遍

	- 马上自己写

		- debug 直到通过

- 第三遍

	- 第二天再做一遍

- 第四遍

	- 一周后再做一遍

		- 一定要去国际版看高票解答！

- 第五遍

	- 面试前再做一遍

### 编码技巧

- 提升效率

	- 熟练使用 IDE 快捷方式

- 自顶向下编程方式

	- 写代码类似写报纸

		- 重点在前，细节在后

	- 先思考主干逻辑

		- 写空函数，直接用

	- 再考虑实现细节

		- 用 IDE 补全函数声明

### 快速学习一门语言

- 直接看Cheatsheet
- 少量多次地重复看

	- 在使用的过程中加深映像

## 数据结构与算法总览

### 数据结构

- 一维

	- 基础

		- 数组：array
		- 链表：linked list

	- 高级

		- 栈：stack
		- 队列：queue

			- 双端队列：deque

		- 集合：set
		- 映射：map/hash

- 二维

	- 基础

		- 树：tree
		- 图：graph

	- 高级

		- 二叉搜索树：BST/red-black tree/AVL
		- 堆：heap
		- 并查集：disjoint set
		- 字典树：Trie

- 特殊

	- 位运算：Bitwise
	- 布隆过滤器：BloomFilter
	- 缓存：LRU Cache

### 算法

- 基石

	- if/else，switch：branch

		- 判断

	- for/while，loop：iteration

		- 循环

	- devide&conquer，backtrace：recursion

		- 递归

- 派生

	- Search

		- 搜索

	- Dynamic Programming

		- 动态规划

	- Binary Search

		- 二分查找

	- Greedy

		- 贪心算法

	- Math&Geometry

		- 数学

## 复杂度分析

### 时间复杂度

- 循环直接看最大次数
- 递归

	- 画出递归树，对所有情况求和
	- Master Theorem

		- 常用分治递推公式

### 空间复杂度

- 数组长度
- 递归深度

	- 递归树的高度

## 数组、链表、跳表

### 基本概念

- 一维基础数据结构

	- 顺序存储

		- 数组

			- prepend、append、lookup

				- O(1)

			- insert、delete

				- O(n)

	- 链式存储

		- 链表

			- prepend、append、insert、delete

				- O(1)

			- lookup

				- O(n)

- 派生数据结构

	- 跳表

		- 只能用于元素有序的情况

			- 对标平衡树和二分查找

		- 一维数据结构的优化常常用到的思想：升维

			- 多一层维度就多一层信息

		- 时间：O(logn)
		- 空间：O(n)

### 解题技巧

- 一维数组坐标变换问题

	- 283.移动零
	- 双指针法

		- 一个指针用于遍历数组
		- 一个指针用于记录变换后的结果

- 一维数组求极值问题

	- 11.盛水容器
	- 左右夹逼法

		- 数组头尾指针逐渐向中间逼近
		- 两者相遇时即遍历完成

- 350.数组交集

	- 进阶三问有疑问

### 解题总纲

- 没有思路的问题

	- 暴力求解
	- 考虑简单情况
	- 找最近重复子问题

		- 循环

			- 原问题的碎片

		- 递归

			- 原问题的缩影

## 栈、队列

### 基本概念

- Stack

	- 先入后出

		- 添加、删除：O(1)
		- 查询：O(n)

- Queue

	- 先入先出

		- 添加、删除：O(1)
		- 查询：O(n)

- Deque: Double-Ended Queue

	- 栈和队列的结合体

		- 添加、删除：O(1)
		- 查询：O(n)

- Priority Queue

	- 插入：O(1)
	- 取出：O(logn)
	- 可有heap、BST、treap多种实现

### 解题技巧

- 栈问体特点

	- 最近相关性
	- 数据只在一段出入

- 队列问题特点

	- 先来后到性
	- 数据会在两端出入

- 单调栈、单调队列

	- 适合解决乱序动态求最值的问题
	- 84.柱状图中最大的矩形
	- 239.滑动窗口最大值
	- 09.用两个栈实现队列

		- 对于长度会变的数组，推荐使用while循环！
		- 用for循环必须先将初始长度赋值给变量，否则循环次数错误！

## 哈希表、映射、集合

### 基本概念

- 哈希表

	- Map/Set

### 解题技巧

## 树、二叉树、二叉搜索树

### 基本概念

- 树

	- 相当于链表的升维

		- 一个next指针变为多个next指针

	- 链表是树的特例，树是图的特例
	- 树的结构天生适合递归，而不适合循环

- 树的遍历

	- 前序
	- 中序
	- 后序

- BST

	- 左子树 < 节点 < 右子树

### 解题技巧

- 二叉树遍历

	- 递归解法
	- 迭代解法

		- 递归的本质就是压栈，故递归写法都可通过栈转换为迭代写法
		- 红黑栈写法模拟函数递归
		- 94.二叉树的中序遍历

## 堆、二叉堆

### 基本概念

- heap

	- 抽象

		- 可以快速找到一组数中最大或最小值的数据结构

	- 实现

		- 二叉堆

			- 基于二叉树

				- 一棵完全二叉树
				- 任意节点值 >= 子节点值

		- 斐波那契堆

			- 基于多叉树

	- 操作

		- find-max：O(1)
		- delete-max：O(logn)

			- 堆尾替换头部，向下堆化

		- insert/create：O(logn)/O(1)

			- 加在堆尾，向上堆化

### 解题技巧

- Top K问题熟练掌握
- 040.最小的k个数
- 347.前k个高频元素

## 图

### 基本概念

- 组成

	- Vertex

		- 入度、出度
		- 连通

	- Edge

		- 有向、无向
		- 权重

- 表示方法

	- 邻接矩阵
	- 邻接表

- 常用算法

	- DFS/BFS

		- 与树的最大区别在于一定要写visited！

	- 高级算法

### 解题技巧

## 泛型递归

### 基本概念

- 递归也是一种循环

	- 通过调用函数体自身来实现

		- 编译后两者没有太大区别

	- 计算机底层由汇编实现，而汇编语言没有循环

		- 它会跳到指定的代码处反复执行

- 类比盗梦空间

	- 每一层梦境是全新的世界，互相不会影响，即为函数上下文
	- 主角可以穿梭于层层梦境之间，即为函数参数
	- 递进与返回必须依次发生，不可跳转

- 递归双子

	- 终止条件
	- 递推公式

		- 处理本层逻辑
		- 进入下层逻辑
		- 清理本层数据

			- 恢复本层某些变量
			- 考虑是否需要返回值，返回值代表什么

- 递归三要点

	- 不要进行人肉递归！
	- 寻找最近重复子问题！
	- 把握数学归纳法思维！

### 解题技巧

- 注意递归进入下一层时，传参时不要使用++/--运算符！

	- 这会将本层的参数修改掉，从而产生错误

- 注意使用for...in...时，返回的是数组的键，不是值！

	- 数组也是对象，只不过键是固定的，为自然数组

- 22.括号生成

## 分治、回溯

### 基本概念

- 本质上就是递归

	- 递归的本质是重复

		- 最近重复性

			- 子问题不相关

				- 分治

					- Devide
					- Conquer
					- Merge

			- 子问题相关

				- 回溯

					- 遍历决策树

		- 最优重复性

			- 动态规划

### 解题技巧

- 排列、组合、子集问题

	- 本质是n个格子，每格决策一次
	- 决定是选哪个，或者是选不选

- 46.全排列
- 78.子集

## 搜索

### 基本概念

- DFS

	- 实现

		- 递归
		- 手动维护栈

	- 场景

		- 更常用的遍历

- BFS

	- 实现

		- 队列

	- 场景

		- 层序遍历
		- 最短路径

			- Dijkstra算法针对有权图，BFS针对无权图

	- 多源BFS

		- 将多个源点同时放入初始队列即可

- 启发式搜索

	- 深度学习

### 解题技巧

- 1143.最长公共子序列
- 动态规划中的状态转移有两种

	- 正向：状态转移表

		- 通常可由回溯算法演变而来
		- 用循环实现

	- 逆向：状态转移方程

		- 思考反向递推的规律
		- 用递归实现，用缓存优化

	- 寻找递推关系时，不妨从两个角度分别考虑

## 贪心算法

### 基本概念

### 解题技巧

- 45.跳跃游戏||

## 二分查找

## 动态规划

### 基本概念

- 定义

	- Divide & Conquer + Optimal Substructure

- 递归、回溯、分治、动态规划

	- 本质上都没有大的区别

		- 差异

			- 关键在于是否存在最优子结构

				- 淘汰次优解

		- 共性

			- 寻找重复性
			- 计算机简单指令集

- 动态规划两要素

	- 状态

		- 提取状态量

			- 用一维或二维数组存储

	- 选择

		- 寻找递推关系

			- 正向/逆向都可考虑

### 解题技巧

- 198.打家劫舍

	- 用自顶向下的记忆式搜索时，判断之前是否计算过，注意写成如下形式，否则值为零的会被跳过
	- if (dp[i] != undefined) {return dp[i]}

- 363.矩形区域不超过k的最大和

	- 二维数组行和列数相差很大时，两种循环遍历会有差别，自增与比较次数相同
	- 不同之处在于i/j的定义与舍弃次数

- 120.三角形最小路径和

	- 如递推关系中常有头尾需要特殊处理，不妨从另一个方向来看，递减则可以规避如此繁琐
	- 递推方向不同，复杂度可能相差很大！

- 152.乘积最大子序列

	- 连续子序列问题的状态设计

		- 抓住以num[i]结尾的连续子序列

	- 状态设计可增加维度以保证无后效性

		- 动态规划只关注阶段性状态，不关心从何而来
		- 回溯算法会关注遍历过程

- 718.最长重复子数组

	- 同样的连续子序列/数组

		- 抓住以A[i]/B[j]结尾的子数组

## 高级动态规划

### 基本概念

- 模版

	- 递归

		- terminator
		- process current logic
		- drill down
		- restore current status

	- 分治

		- terminator
		- split & conquer subproblems
		- merge result
		- revert current states

	- 动态规划

		- divide & conquer
		- optimal substructure

- 高级动态规划

	- 更高维度的状态
	- 更复杂的状态转移

### 解题技巧

- 300.最长上升子序列

	- 子序列

		- 不要求连续

			- subsequence

	- 子串

		- 要求连续

			- subarray
			- substring

- 72.编辑距离

	- 加上哨兵行与列时，注意原数组下标需减一，否则会错位

- 91.解码方法

	- 三目表达式参与计算时注意外面要加括号，否则可能会打乱运算顺序

- 32.最长有效括号

	- 遇到复杂的动态规划还是要抓住最近子问题
	- 连续子串关注前一位的所有可能性和与当前位的递推关系
	- 括号问题总可以用栈解决

## 字符串算法

### 基本概念

- Js中字符串

	- Immutable

### 解题技巧

## Js速查

### 基本概念

- 数据类型

	- 原始数据类型

		- Number
		- String
		- Boolean
		- Symbol

	- 特殊数据类型

		- null
		- undefined

	- 复合数据类型

		- Object

			- Object
			- Array
			- Function

- 函数

	- 作用域

		- 函数本身也是一个值，也有自己的作用域
		- 它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关

	- 参数

		- 原始类型的值(数值、字符串、布尔值)，传递方式为传值传递(passes by value)

			- 即，在函数体内修改参数值，不会影响函数外部

		- 复合类型的值(数组、对象、其他函数)，传递方式是传址传递(pass by reference)

			- 即，传入函数的是原始值的地址，因此在函数内部修改参数，将会影响到原始值
			- 注意，如果函数内部修改的不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值，因为相当于地址变了

- 集合/映射

	- Set

		- 可用于数组/字符串去重

			- [...new Set(array)]
			- [...new Set('ababbc')].join('')

	- Map

- 数组

	- slice

		- 不会改变原数组
		- 返回值为原数组的浅拷贝

	- splice

		- 会改变原数组
		- 返回值为数组形式的被修改内容

	- fill

		- 以固定值填充数组，可用于快速初始化数组

- 运算符

	- 乘方运算

		- a ** b

	- 比较运算

		- 非相等

			- 先看两个算子是否都为字符串

				- 按照字典顺序比较(Unicode 码点)

			- 否则将两个算子都转成数值，再比较数值的大小

		- 相等

			- 原始类型值会转换成数值再进行比较

	- 算术运算

		- 除了加法运算符有可能把算子转为字符串，其他运算符都会把算子自动转成数值

	- 位运算

		- 移位

			- <<

				- 左移
				- <<0

					- 将数值转为32位整数，等同于取整，正负有效

			- >>>

				- 无符号右移
				- >>>0

					- 将数值转为32位无符号整数

			- >>

				- 有符号右移，负数右移仍为负数
				- >>1

					-  将数值做2的整除运算

		- 注意点

			- 位运算优先级比==低，需使用括号保证运算顺序
			- 补码表示法即为所有位取反加一

		- 常用技巧

			- x&(-x)可获取二进制中最右边的1
			- x&(x-1)可去除二进制中最右边的1

- 布尔值

	- 以下五类值会被转换成false，其余皆转为true，可以活用于if判断语句中

		- undefined
		- null
		- 0
		- NaN
		- null string

- 正则表达式

	- 元字符

		- 点字符.

			- 匹配\r\n等少数以外的所有字符

		- 位置字符^$

			- 表示字符串开始结束

		- 选择字符|

			- 表示或的关系

		- 转义字符\

			- 用于匹配元字符本身

	- 字符类[]

		- 表示一系列字符可供选择
		- 脱字符^

			- 匹配除字符类以外的所有字符

		- 连字符-

			- 匹配连续范围的字符

	- 预定义模式

		- \d\D

			- 匹配数字\非数字

		- \w\W

			- 匹配字母数字下划线

		- \s\S

			- 匹配多种空格

	- 重复类{}

		- 匹配精确次数{n, m}

			- 不少于n次，不多于m次

		- 量词字符

			- ? = {0, 1}
			- * = {0,}
			- + = {1,}

		- 非贪婪模式

			- 量词后加?

	- 修饰符

		- 全局匹配g

			- 多用于搜索和替换

		- 忽略大小写i
		- 多行模式m

	- 组匹配()
	- 特殊字符

		- \n\r\t等不可打印的字符

*XMind - Trial Version*